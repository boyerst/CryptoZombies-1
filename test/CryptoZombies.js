// First thing have to do when writing new test suite is to load the build artifacts of the contract you want to interact with
  // The function you use to load the build artifacts will return a 'contract abstraction

const CryptoZombies = artifacts.require("CryptoZombies");
// Initialize zombie names as a global array
  // Instead of giving names to Alice and Bob's zombies for each test
  // This way we can just call the contract's methods like this...
    // contractInstance.createRandomZombie(zombieNames[0]);

const zombieNames = ["Zombie 1", "Zombie 2"];
contract("CryptoZombies", (accounts) => {
    // Initialize palceholders for accounts in array because using accounts[0] and accounts[1] wouold noit make our tests read well
    let [alice, bob] = accounts;


    let contractInstance;

    // Create a contract instance using our contract abstraction and set equal to the result of the CryptoZombies.new() function
        // In order to interact with our smart contract we have to create a JS object that will act as an instance of the contract
    beforeEach(async () => {
        contractInstance = await CryptoZombies.new();
    });


    it("should be able to create a new zombie", async() => {
        // Declare result which contains Logs and Events + tx hash, tx receipt, and more
          // We also append {from: } to tell the test who is "calling" the function and making the zombie
        const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        // Using assert module to determine success of the tx - if true = successful
          // "assert wether the status of this tx is equal to true"
        assert.equal(result.receipt.status, true);
        // Using assert module one more time to double check wether test has been passed
          // We retreive Alice's new zombies' name from the logs automatically generated by Truffle when we specified the contract we wanted to test using artifacts.require
          // The name is result.logs[0].args.name
        // "assert wether the name of the zombie from the logs generated by Truffle is the same as the name of the zombie in our global array"
        assert.equal(result.logs[0].args.name,zombieNames[0]);
    })


    it("should not allow two zombies", async () => {
      // Alice calls createRandomZombie and names is zombiesNames[1]
      await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
      // Alice tries to create her second zombie and set the name to zombieNames[1]
        // We are expecting this to throw an error as alice is only allowed to create 1 zombie
        // the shouldThrow code is long and dirty lookin' so we moved it to a file in /test/helpers dir
      await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));        
    })


    context("with the single-step transfer scenario", async () => {
      it("should transfer a zombie", async () => {
        // Create a new zombie for Alice (Remember that a zombie is nothing more than an ERC721 token).
          // The first line of the function should call createRandomZombie. Give it zombieNames[0] as the name and make sure Alice is the owner
        const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        // The second line should declare a const named zombieId and set it equal to the zombie's id
          // We grab it from the logs generated by Truffle and we convert it to a number because ❓
        const zombieId = result.logs[0].args.zombieId.toNumber();
        // Make it so that Alice transfers her ERC721 token to Bob
          // The original function takes three args: address _from, address _to, uint256 _tokenId)
        await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
        // At this point, Bob should own the ERC721 token. If so, ownerOf would return a value that is equal to Bob's address
          // Declare a const called newOwner. Set it equal to ownerOf called with zombieId.
        const newOwner = await contractInstance.ownerOf(zombieId);
        // Let's wrap it up by checking if Bob is the newOwner, inside an assert.
          // check whether Bob owns this ERC721 token. Putting this into code, it means we should run assert.equal with newOwner and bob as parameters
        assert.equal(newOwner, bob);
      })
    })

       
    context("with the two-step transfer scenario", async () => {
      // Test the two-step scenario.  The approved address calls transferFrom
        // Alice approves Bob to take the ERC721 token, then Bob (the approved address) calls transferFrom
      it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
        // This test is similar to single-step transfer so we copy the majority of the code...
        const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        const zombieId = result.logs[0].args.zombieId.toNumber();
        await contractInstance.approve(bob, zombieId, {from: alice});
        await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
        const newOwner = await contractInstance.ownerOf(zombieId);
        assert.equal(newOwner,bob);

      })

      // Test the two-step scenario.  The owner calls transferFrom
        // Alice approves Bob to take the ERC721 token. Next, Alice transfers the ERC721 token
      it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
        const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        const zombieId = result.logs[0].args.zombieId.toNumber();
        await contractInstance.approve(bob, zombieId, {from: alice});
        await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
        const newOwner = await contractInstance.ownerOf(zombieId);
        assert.equal(newOwner,bob);
      })
    })




})
